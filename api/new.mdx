---
title: "New"
description: "The New function creates a Broccoli instance from a compressed bundle"
---

## Overview

The `New` function decompresses a bundle byte-slice and creates a virtual file system. It's called from generated code to initialize the Broccoli file system.

<Note>
  This function is only supposed to be called from the generated code produced by the broccoli tool.
</Note>

## Function Signature

```go
func New(opt bool, bundle []byte) *Broccoli
```

## Parameters

<ParamField path="opt" type="bool" required>
  Optional decompression mode:
  - `true`: Keep files compressed, decompress on-demand when opened
  - `false`: Decompress all files immediately during initialization
</ParamField>

<ParamField path="bundle" type="[]byte" required>
  The compressed bundle byte slice generated by the Pack function.
</ParamField>

## Return Value

<ResponseField name="*Broccoli" type="*Broccoli">
  A pointer to a Broccoli instance ready for use.
</ResponseField>

<Note>
  The function panics if the bundle cannot be decompressed or decoded. This is intentional as bundle corruption indicates a critical error during code generation.
</Note>

## Behavior

### Immediate Decompression (opt = false)

When `opt` is `false`, all files are decompressed immediately in parallel:

1. The bundle is decompressed and decoded
2. All files are decompressed using parallel workers (one per CPU core)
3. The Broccoli instance is ready with all files in memory

**Advantages:**
- Faster file access (no decompression delay)
- Predictable memory usage

**Disadvantages:**
- Slower startup time
- Higher initial memory usage

### On-Demand Decompression (opt = true)

When `opt` is `true`, files remain compressed and are decompressed only when opened:

1. The bundle is decompressed and decoded
2. Files remain in compressed form
3. Decompression happens in `File.Open()`

**Advantages:**
- Faster startup time
- Lower initial memory usage

**Disadvantages:**
- Slight delay when opening files
- Higher CPU usage during file access

## Implementation Details

```go
func New(opt bool, bundle []byte) *Broccoli {
    var files []*File
    r := brotli.NewReader(bytes.NewBuffer(bundle))
    if err := gob.NewDecoder(r).Decode(&files); err != nil {
        panic(err)
    }
    
    br := &Broccoli{
        filePaths: make([]string, 0, len(files)),
        files:     map[string]*File{},
    }
    
    // Initialize file mappings
    for _, f := range files {
        f.compressed = true
        f.br = br
        
        br.files[f.Fpath] = f
        br.filePaths = append(br.filePaths, f.Fpath)
    }
    
    if opt {
        return br
    }
    
    // Parallel decompression using all CPU cores
    n := runtime.NumCPU()
    feed := make(chan *File)
    done := make(chan struct{}, n)
    
    for i := 0; i < n; i++ {
        go func() {
            for f := range feed {
                if err := f.decompress(f.Data); err != nil {
                    panic(errors.Wrap(err, "could not decompress"))
                }
            }
            done <- struct{}{}
        }()
    }
    
    for _, file := range files {
        feed <- file
    }
    close(feed)
    
    // Wait for all workers
    for range done {
        n--
        if n == 0 {
            break
        }
    }
    
    return br
}
```

## Usage in Generated Code

The broccoli tool generates code that calls New:

```go
package assets

import "aletheia.icu/broccoli/fs"

// Generated by broccoli
var bundle = []byte{
    // Compressed bundle data...
}

// Assets is the virtual file system
var Assets = fs.New(false, bundle)
```

## Usage Examples

**Example 1: Using generated assets**

```go
package main

import (
    "log"
    "net/http"
    "myapp/assets"
)

func main() {
    // The Assets variable is already initialized by the generated code
    http.Handle("/static/", http.StripPrefix("/static/", assets.Assets.Serve("public")))
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

**Example 2: Reading a bundled file**

```go
file, err := assets.Assets.Open("templates/index.html")
if err != nil {
    log.Fatal(err)
}
defer file.Close()

data, err := io.ReadAll(file)
if err != nil {
    log.Fatal(err)
}
fmt.Println(string(data))
```

**Example 3: Development mode**

```go
if os.Getenv("ENV") == "development" {
    assets.Assets.Development(true)
}
```

## Performance Considerations

<Note>
  Choose the decompression mode based on your use case:
  - **Web servers**: Use `opt = false` for faster response times
  - **CLI tools**: Use `opt = true` for faster startup
  - **Large bundles**: Use `opt = true` to reduce memory usage
  - **Small bundles**: Use `opt = false` for simplicity
</Note>